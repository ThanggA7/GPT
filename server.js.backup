import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import path from "path";
import { fileURLToPath } from "url";

dotenv.config();

const app = express();
app.use(express.json({ limit: "25mb" }));
app.use(cors()); // Enable CORS for all routes

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
app.use(express.static(path.join(__dirname, "public")));

const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';

if (!GEMINI_API_KEY) {
  console.error("‚ùå Thi·∫øu GEMINI_API_KEY trong .env");
  process.exit(1);
}

const PORT = process.env.PORT || 5500;

app.options("/api/chat", (req, res) => res.sendStatus(204));

app.post("/api/chat", async (req, res) => {
  console.log("üì® Received chat request:", {
    hasMessage: !!req.body?.message,
    imageCount: req.body?.images?.length || 0,
    temperature: req.body?.temperature,
  });

  try {
    const { message, images = [], temperature = 0.7 } = req.body || {};
    
    // Validate input - message should be non-empty string or images should be provided
    const hasMessage = message && typeof message === 'string' && message.trim().length > 0;
    const hasImages = images && Array.isArray(images) && images.length > 0;

    if (!hasMessage && !hasImages) {
      return res.status(400).json({ 
        error: 'Message or images required',
        details: 'Please provide either a text message or upload images'
      });
    }

    const parts = [];
    
    // Add text message if provided
    if (hasMessage) {
      parts.push({ text: message.trim() });
    }

    // Add images if provided
    if (hasImages) {
      for (const image of images) {
        parts.push({
          inline_data: {
            mime_type: image.mimeType || 'image/jpeg',
            data: image.data.split(',')[1] // Remove data:image/jpeg;base64, prefix
          }
        });
      }
    }

    const requestBody = {
      contents: [{
        parts: parts
      }],
      generationConfig: {
        temperature: Math.max(0, Math.min(1, temperature)),
        maxOutputTokens: 4096,
        topP: 0.8,
        topK: 40
      },
      safetySettings: [
        {
          category: "HARM_CATEGORY_HARASSMENT",
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        },
        {
          category: "HARM_CATEGORY_HATE_SPEECH", 
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        },
        {
          category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        },
        {
          category: "HARM_CATEGORY_DANGEROUS_CONTENT",
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        }
      ]
    };

    console.log("ü§ñ Calling Gemini API with", hasImages ? 'text + images' : 'text only');

    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody)
    });

    const data = await response.json();

    if (!response.ok) {
      console.error('‚ùå Gemini API Error:', data);
      throw new Error(data.error?.message || 'API request failed');
    }

    if (!data.candidates || data.candidates.length === 0) {
      throw new Error('No response generated');
    }

    const candidate = data.candidates[0];
    
    // Check for safety filters
    if (candidate.finishReason === 'SAFETY') {
      return res.status(400).json({
        error: 'N·ªôi dung b·ªã ch·∫∑n do vi ph·∫°m ch√≠nh s√°ch an to√†n',
        safetyRatings: candidate.safetyRatings
      });
    }

    // Check for other finish reasons
    if (candidate.finishReason === 'RECITATION') {
      return res.status(400).json({
        error: 'N·ªôi dung b·ªã ch·∫∑n do vi ph·∫°m b·∫£n quy·ªÅn'
      });
    }

    if (!candidate.content?.parts?.[0]?.text) {
      console.error('‚ùå Invalid response structure:', data);
      return res.status(500).json({
        error: 'Ph·∫£n h·ªìi kh√¥ng h·ª£p l·ªá t·ª´ AI',
        finishReason: candidate.finishReason
      });
    }

    const aiResponse = candidate.content.parts[0].text;
    
    console.log("‚úÖ Sending response, length:", aiResponse.length);
    res.status(200).json({
      message: aiResponse,
      finishReason: candidate.finishReason,
      safetyRatings: candidate.safetyRatings
    });

  } catch (error) {
    console.error('‚ùå Server error:', error);
    
    let errorMessage = 'Xin l·ªói, t√¥i kh√¥ng th·ªÉ x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n l√∫c n√†y.';
    
    if (error.message.includes('API key')) {
      errorMessage = 'L·ªói c·∫•u h√¨nh API key';
    } else if (error.message.includes('quota') || error.message.includes('limit')) {
      errorMessage = 'ƒê√£ v∆∞·ª£t qu√° gi·ªõi h·∫°n API, vui l√≤ng th·ª≠ l·∫°i sau';
    } else if (error.message.includes('network') || error.message.includes('fetch')) {
      errorMessage = 'L·ªói k·∫øt n·ªëi m·∫°ng, vui l√≤ng th·ª≠ l·∫°i';
    }
    
    res.status(500).json({
      error: errorMessage,
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// For local development
if (process.env.NODE_ENV !== 'production') {
  app.listen(PORT, () => {
    console.log(`‚úÖ Server running at http://localhost:${PORT}`);
  });
}

// Export for Vercel serverless
export default app;

app.post("/api/chat", async (req, res) => {
  console.log("üì® Received chat request:", {
    hasMessage: !!req.body?.message,
    imageCount: req.body?.images?.length || 0,
    temperature: req.body?.temperature,
  });

  try {
    const { message, images = [], temperature = 0.7 } = req.body || {};
    
    // Validate input - message should be non-empty string or images should be provided
    const hasMessage = message && typeof message === 'string' && message.trim().length > 0;
    const hasImages = images && Array.isArray(images) && images.length > 0;

    if (!hasMessage && !hasImages) {
      return res.status(400).json({ 
        error: 'Message or images required',
        details: 'Please provide either a text message or upload images'
      });
    }

    // SSE headers
    res.setHeader("Content-Type", "text/event-stream; charset=utf-8");
    res.setHeader("Cache-Control", "no-cache, no-transform");
    res.setHeader("Connection", "keep-alive");
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type");

    // Ch·ªâ g·ª≠i messages role user/assistant, b·ªè system (Gemini kh√¥ng h·ªó tr·ª£ system)
    const geminiMessages = messages
      .filter((m) => m.role !== "system")
      .map((m) => {
        if (typeof m.content === "string") {
          return { role: m.role, parts: [{ text: m.content }] };
        } else if (Array.isArray(m.content)) {
          // X·ª≠ l√Ω message v·ªõi text v√† image
          const parts = [];

          m.content.forEach((item) => {
            if (item.type === "text" && item.text) {
              parts.push({ text: item.text });
            } else if (item.type === "image_url" && item.image_url) {
              // Convert data URL to Gemini format
              const dataUrl = item.image_url.url;
              if (dataUrl.startsWith("data:image/")) {
                const [header, base64Data] = dataUrl.split(",");
                const mimeType =
                  header.match(/data:(image\/[^;]+)/)?.[1] || "image/jpeg";

                parts.push({
                  inline_data: {
                    mime_type: mimeType,
                    data: base64Data,
                  },
                });
              }
            }
          });

          return {
            role: m.role,
            parts: parts.length > 0 ? parts : [{ text: "" }],
          };
        } else {
          return { role: m.role, parts: [{ text: "" }] };
        }
      });

    // G·ªçi Gemini API (s·ª≠ d·ª•ng gemini-1.5-flash ƒë·ªÉ h·ªó tr·ª£ vision t·ªët h∆°n)
    console.log(
      "ü§ñ Calling Gemini API with",
      geminiMessages.length,
      "messages"
    );

    // Check if any message contains images
    const hasImages = geminiMessages.some((msg) =>
      msg.parts.some((part) => part.inline_data)
    );

    const model = hasImages ? "gemini-1.5-flash" : "gemini-1.5-flash";
    console.log(
      "üì∏ Using model:",
      model,
      hasImages ? "(with vision)" : "(text only)"
    );

    const upstream = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${GEMINI_API_KEY}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          contents: geminiMessages,
          generationConfig: { temperature },
        }),
      }
    );

    if (!upstream.ok) {
      const errorText = await upstream.text();
      console.error("‚ùå Gemini API error:", upstream.status, errorText);
      res.write(
        `event: error\ndata: ${JSON.stringify({
          error: `API Error: ${upstream.status}`,
        })}\n\n`
      );
      return res.end();
    }

    // Gemini 1.5 Flash response handling with better error checking
    const data = await upstream.json();
    console.log("‚úÖ Gemini response received", JSON.stringify(data, null, 2));

    const candidates = data.candidates?.[0];
    
    // Check for safety ratings or blocked content
    if (!candidates) {
      console.log("‚ö†Ô∏è No candidates in response, might be blocked by safety filters");
      const finishReason = data.candidates?.[0]?.finishReason;
      let errorMessage = "Xin l·ªói, t√¥i kh√¥ng th·ªÉ t·∫°o ph·∫£n h·ªìi cho n·ªôi dung n√†y.";
      
      if (finishReason === 'SAFETY') {
        errorMessage = "N·ªôi dung c√≥ th·ªÉ vi ph·∫°m ch√≠nh s√°ch an to√†n. Vui l√≤ng th·ª≠ c√¢u h·ªèi kh√°c.";
      } else if (finishReason === 'RECITATION') {
        errorMessage = "N·ªôi dung c√≥ th·ªÉ vi ph·∫°m b·∫£n quy·ªÅn. Vui l√≤ng th·ª≠ c√¢u h·ªèi kh√°c.";
      }
      
      res.write(`data: ${JSON.stringify({ token: errorMessage })}\n\n`);
      res.write("data: [DONE]\n\n");
      return res.end();
    }
    
    // Check finish reason
    const finishReason = candidates.finishReason;
    if (finishReason && finishReason !== 'STOP') {
      console.log("‚ö†Ô∏è Unusual finish reason:", finishReason);
      let warningMessage = "";
      
      if (finishReason === 'MAX_TOKENS') {
        warningMessage = "\n\n*[Ph·∫£n h·ªìi c√≥ th·ªÉ b·ªã c·∫Øt do gi·ªõi h·∫°n ƒë·ªô d√†i]*";
      } else if (finishReason === 'SAFETY') {
        warningMessage = "\n\n*[M·ªôt ph·∫ßn n·ªôi dung c√≥ th·ªÉ b·ªã l·ªçc v√¨ l√Ω do an to√†n]*";
      }
      
      const token = candidates?.content?.parts?.[0]?.text ?? "";
      if (token) {
        res.write(`data: ${JSON.stringify({ token: token + warningMessage })}\n\n`);
      } else {
        res.write(`data: ${JSON.stringify({ token: "Ph·∫£n h·ªìi b·ªã l·ªçc v√¨ l√Ω do an to√†n." + warningMessage })}\n\n`);
      }
      res.write("data: [DONE]\n\n");
      return res.end();
    }

    const token = candidates?.content?.parts?.[0]?.text ?? "";

    if (token) {
      console.log("üì§ Sending response token, length:", token.length);
      res.write(`data: ${JSON.stringify({ token })}\n\n`);
    } else {
      console.log("‚ö†Ô∏è Empty response token, sending fallback message");
      res.write(
        `data: ${JSON.stringify({
          token: "Xin l·ªói, t√¥i ƒë√£ hi·ªÉu c√¢u h·ªèi c·ªßa b·∫°n nh∆∞ng kh√¥ng th·ªÉ t·∫°o ph·∫£n h·ªìi ph√π h·ª£p l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c ƒë·∫∑t c√¢u h·ªèi kh√°c.",
        })}\n\n`
      );
    }

    res.write("data: [DONE]\n\n");
    res.end();
  } catch (err) {
    console.error("‚ùå Server error:", err);
    res.write(
      `event: error\ndata: ${JSON.stringify({ error: err.message })}\n\n`
    );
    res.end();
  }
});

// For local development
if (process.env.NODE_ENV !== 'production') {
  app.listen(PORT, () => {
    console.log(`‚úÖ Server running at http://localhost:${PORT}`);
  });
}

// Export for Vercel serverless
export default app;
